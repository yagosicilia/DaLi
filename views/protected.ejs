<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dali</title>
  <link rel="stylesheet" href="/css/styles.css" />
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #ffffff;
    }

    nav {
      margin-bottom: 20px;
    }

    nav button {
      margin-right: 10px;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
    }

    .seccion {
      display: none;
    }

    .seccion.activa {
      display: block;
    }

    input, button {
      margin-top: 8px;
    }
  </style>
</head>
<body>

  <nav>
    <button data-seccion="inicio">Inicio</button>
    <button data-seccion="misnfts">Mis NFTs</button>
    <button data-seccion="subir">Subir Obra</button>
    <button data-seccion="transferir">Transferir Obra</button>
    <button data-seccion="pujar">Pujar</button>
    <button id="cerrarSesion">Cerrar sesi√≥n</button>
  </nav>

  <main>
    <section id="inicio" class="seccion activa">
      <p>Selecciona una secci√≥n del men√∫ para comenzar.</p>
    </section>
    <section id="misnfts" class="seccion">
      <h2>Mis NFTs</h2>
      <p id="misnfts-status">Pulsa el bot√≥n para cargar tus obras.</p>
      <button id="misnfts-refrescar">Actualizar listado</button>
      <div id="misnfts-contenedor" style="display:grid; gap:12px; margin-top:16px;"></div>
    </section>    

    <section id="subir" class="seccion">
        <h2>Registrar una Obra como NFT</h2>
        <p>Est√°s registrando como: <strong><%= username %></strong></p>
      
        <button id="btnConectar">Conectar a Metamask</button>
      
        <form id="formRegistro" style="margin-top: 20px;">
          <label for="archivo">Seleccionar imagen:</label><br>
          <input type="file" id="archivo" required /><br><br>
      
          <button type="button" id="btnRegistrar">Registrar Obra</button>
        </form>
      
        <div id="respuesta"></div>
    </section>
      

    <section id="transferir" class="seccion">
      <h2>Transferir Obra</h2>
      <form id="formTransferir">
        <label for="transfer-tokenId">Token‚ÄØID:</label><br />
        <input type="number" id="transfer-tokenId" placeholder="Ej.‚ÄØ1" required /><br /><br />
      
        <label for="transfer-address">Destino (usuario, ENS o 0x):</label><br/>
        <input type="text" id="transfer-address" placeholder="Rodri o 0x123‚Ä¶" required><br><br>

      
        <button type="button" id="btnTransferir">Transferir NFT</button>
      </form>
      <div id="transfer-status" style="margin-top:12px;"></div>
    </section>

    <section id="pujar" class="seccion">
      <h2>Pujar por una obra</h2>
      <p>[Aqu√≠ puedes implementar un sistema de pujas o marketplace]</p>
    </section>
  </main>

  <script>
    // Navegaci√≥n entre secciones
    const secciones = document.querySelectorAll(".seccion");
    const botones = document.querySelectorAll("nav button[data-seccion]");

    botones.forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-seccion");
        secciones.forEach(sec => sec.classList.remove("activa"));
        document.getElementById(id).classList.add("activa");
      });
    });

    document.getElementById("cerrarSesion").addEventListener("click", async () => {
      await fetch("/logout", { method: "POST" });
      window.location.href = "/";
    });
  </script>



  <!-- Script de subida y registro de NFT -->
  <script type="module">
    const autor = "<%= username %>";
    const walletDelUsuario = "<%= walletAddress %>";
    import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.min.js";
    import contractABI from "/ABI.js";

    console.log("ABI importado:", contractABI);

    const contractAddress = "0xc4446571ad11804b84305e42d3a79098b1cf1f48";
    let metamaskConectado = false;

    document.getElementById("btnConectar").addEventListener("click", async () => {
        if (!window.ethereum) {
            alert("MetaMask no est√° instalado.");
            return;
        }

        try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            const cuentaConectada = accounts[0];

            console.log("üëâ Cuenta conectada desde MetaMask:", cuentaConectada);
            console.log("üëâ Wallet registrada en servidor:", walletDelUsuario);

            if (cuentaConectada.toLowerCase() !== walletDelUsuario.toLowerCase()) {
                alert("‚ö†Ô∏è Esta cuenta de MetaMask no coincide con la registrada.");
                return;
            }

            metamaskConectado = true;
            alert("MetaMask conectado correctamente.");
        } catch (err) {
            alert("Error al conectar MetaMask: " + err.message);
        }
    });


    document.getElementById("btnRegistrar").addEventListener("click", async () => {
      const file = document.getElementById("archivo").files[0];
      const respuesta = document.getElementById("respuesta");

      if (!autor || !file) {
        alert("Completa los campos: autor y archivo.");
        return;
      }

      respuesta.innerText = "Subiendo archivo a IPFS, espera...";

      try {
        const formData = new FormData();
        formData.append("autor", autor);
        formData.append("miArchivo", file);

        const resp = await fetch("/subir-archivo", {
          method: "POST",
          body: formData
        });

        if (!resp.ok) throw new Error("Error al subir archivo al servidor");

        const data = await resp.json();
        const tokenURI = data.tokenURI;

        if (!metamaskConectado) {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          metamaskConectado = true;
        }

        respuesta.innerText = "Firmando y registrando en la blockchain...";

        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer = await provider.getSigner();
        const contrato = new ethers.Contract(contractAddress, contractABI, signer);
        const tx = await contrato.registrarObra(tokenURI);

        const receipt = await tx.wait();
        let tokenId = "desconocido";
        try {
          tokenId = parseInt(receipt.logs[0].topics[3], 16);
        } catch {}

        respuesta.innerHTML = `
          <h3>Obra registrada con √©xito</h3>
          <p><strong>Token ID:</strong> ${tokenId}</p>
          <p>IPFS: <a href="${tokenURI}" target="_blank">${tokenURI}</a></p>
          <p>Etherscan: 
            <a href="https://sepolia.etherscan.io/tx/${tx.hash}" target="_blank">
              ${tx.hash}
            </a>
          </p>
        `;
      } catch (error) {
        console.error(error);
        respuesta.innerText = "Error: " + error.message;
      }
    });
    /* --------------------------  L√ìGICA TRANSFERENCIA  -------------------------- */

    const formTransferir   = document.getElementById("formTransferir");
    const btnTransferir    = document.getElementById("btnTransferir");
    const transferStatus   = document.getElementById("transfer-status");

    // Validaci√≥n de direcci√≥n con ethers.js
    const esDireccionValida = (addr) => ethers.isAddress(addr);

    btnTransferir.addEventListener("click", async () => {
      // --- datos b√°sicos del formulario ---
      const tokenIdStr = document.getElementById("transfer-tokenId").value.trim();
      const destInput  = document.getElementById("transfer-address").value.trim();

      /* ‚îÄ‚îÄ validaci√≥n del Token ID ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      if (!tokenIdStr || isNaN(tokenIdStr) || BigInt(tokenIdStr) < 0n) {
        alert("Introduce un Token ID v√°lido.");
        return;
      }
      if (!metamaskConectado) { alert("Conecta MetaMask primero."); return; }

      /* ‚îÄ‚îÄ 1. Resolver la entrada a direcci√≥n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      let destAddr;
      if (ethers.isAddress(destInput)) {
        destAddr = destInput;                       // direcci√≥n 0x directa
      } else {
        // 1) lookup en tu backend (alias BD)
        try {
          const resp = await fetch(`/wallet/${encodeURIComponent(destInput)}`);
          if (resp.ok) {
            const data = await resp.json();
            destAddr = data.walletAddress;
            console.log(`[üìñ] Alias BD ‚Üí ${destAddr}`);
          }
        } catch { /* si falla, pasa a ENS */ }

        // 2) si no est√° en BD ‚áí probar ENS
        if (!destAddr) {
          const provider = new ethers.BrowserProvider(window.ethereum);
          destAddr = await provider.resolveName(destInput);
          if (destAddr) console.log(`[üåê] ENS resuelto ‚Üí ${destAddr}`);
        }

        if (!destAddr) {            // no se resolvi√≥
          alert("No se pudo resolver nombre de usuario ni ENS.");
          return;
        }
      }

      /* ‚îÄ‚îÄ 2. Ejecutar la transferencia ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      try {
        transferStatus.style.color = "black";
        transferStatus.innerText   = "Enviando transacci√≥n‚Ä¶ espera confirmaci√≥n de MetaMask.";

        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer   = await provider.getSigner();
        const fromAddr = await signer.getAddress();
        const contrato = new ethers.Contract(contractAddress, contractABI, signer);

        const tx = await contrato.safeTransferFrom(fromAddr, destAddr, BigInt(tokenIdStr));
        transferStatus.innerText = `Tx enviada: ${tx.hash.slice(0,10)}‚Ä¶\nEsperando confirmaci√≥n‚Ä¶`;

        await tx.wait();
        transferStatus.style.color = "green";
        transferStatus.innerHTML = `
          ‚úÖ Transferencia confirmada a ${destInput}.<br/>
          <a href="https://sepolia.etherscan.io/tx/${tx.hash}" target="_blank">Ver en Etherscan</a>
        `;
        // cargarMisNFTs();   // (opcional) refrescar listado
      } catch (err) {
        console.error(err);
        transferStatus.style.color = "red";
        transferStatus.innerText = "‚ùå Error: " + (err?.message || err);
      }
    });

    
    /* ============================================================= */
    /* ===      MIS NFTs ¬∑ ELEMENTOS DEL DOM (deben ir primero)   ==== */
    /* ============================================================= */
    const btnRefrescar   = document.getElementById("misnfts-refrescar");
    const contenedorNFTs = document.getElementById("misnfts-contenedor");
    const statusNFTs     = document.getElementById("misnfts-status");

    /* ============================================================= */
    /* ===  UTILIDADES GEN√âRICAS (conexi√≥n y escaneo din√°mico)     ==== */
    /* ============================================================= */

    /** Conecta MetaMask si no hay cuentas visibles                  */
    async function asegurarConexion() {
      if (!window.ethereum) throw new Error("MetaMask no detectado");
      const cuentas = await window.ethereum.request({ method: "eth_accounts" });
      if (cuentas.length === 0) {
        console.log("[üîë]¬†No hab√≠a cuentas autorizadas ‚Üí pidiendo acceso");
        await window.ethereum.request({ method: "eth_requestAccounts" });
      } else {
        console.log(`[üîë]¬†Cuenta ya autorizada: ${cuentas[0]}`);
      }
    }

    /** Encuentra el MAX tokenId existente v√≠a b√∫squeda exponencial + binaria */
    async function hallarMaxTokenId(contrato) {
      let hi = 1n;
      for (;;) {
        try { await contrato.ownerOf(hi); hi <<= 1n; }   // duplica: 1,2,4,8‚Ä¶
        catch { break; }
      }
      let lo = hi >> 1n;
      while (lo + 1n < hi) {
        const mid = (lo + hi) >> 1n;
        try { await contrato.ownerOf(mid); lo = mid; }
        catch { hi = mid; }
      }
      return lo;                               // √∫ltimo que existe
    }

    /** Escanea del 1 al maxTokenId y devuelve los que son del owner */
    async function tokenIdsPorScan(contrato, owner) {
      const maxId   = await hallarMaxTokenId(contrato);
      console.log(`[üîç]¬†M√°ximo tokenId hallado ‚Üí ${maxId}`);

      const balance = await contrato.balanceOf(owner);
      const ids     = [];

      for (let id = 1n; id <= maxId && ids.length < balance; id++) {
        try {
          const o = await contrato.ownerOf(id);
          if (o.toLowerCase() === owner.toLowerCase()) ids.push(id);
        } catch { /* token no existe o quemado */ }
      }
      console.log(`[‚úÖ]¬†Escaneo completo: ${ids.length} tokens del usuario`);
      return ids;
    }

    /* ============================================================= */
    /* ===               FUNCI√ìN PRINCIPAL DE LISTADO            ==== */
    /* ============================================================= */

    async function cargarMisNFTs() {
      try {
        await asegurarConexion();

        statusNFTs.innerText  = "Consultando blockchain‚Ä¶";
        contenedorNFTs.innerHTML = "";

        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer   = await provider.getSigner();
        const myAddr   = await signer.getAddress();
        const contrato = new ethers.Contract(contractAddress, contractABI, provider);

        console.log(`[üëõ]¬†Wallet conectada: ${myAddr}`);

        let tokenIds = [];

        if (typeof contrato.tokenOfOwnerByIndex === "function") {
          /* -------- Enumeraci√≥n nativa (ERC721Enumerable) -------- */
          const balance = await contrato.balanceOf(myAddr);
          for (let i = 0n; i < balance; i++) {
            tokenIds.push(await contrato.tokenOfOwnerByIndex(myAddr, i));
          }
          console.log(`[üìä]¬†tokenOfOwnerByIndex ‚Üí ${tokenIds.length} tokens`);
        } else {
          /* -------- Escaneo din√°mico sin l√≠mite previo -------- */
          tokenIds = await tokenIdsPorScan(contrato, myAddr);
        }

        if (tokenIds.length === 0) {
          statusNFTs.innerText = "No tienes NFTs en este contrato.";
          return;
        }

        statusNFTs.innerText = `Encontrados ${tokenIds.length} NFTs ‚Äî cargando metadatos‚Ä¶`;

        for (const id of tokenIds) {
          let uri = "", meta = {};
          try {
            uri  = await contrato.tokenURI(id);
            meta = await fetch(uri).then(r => r.json());
          } catch (e) {
            console.warn(`‚ö†Ô∏è  Metadata no accesible para token ${id}`, e);
          }

          const card = document.createElement("div");
          card.style.cssText =
            "border:1px solid #ddd;border-radius:8px;padding:12px;max-width:200px";
          card.innerHTML = `
            <img src="${meta.image || ""}" style="width:100%;border-radius:6px"/>
            <h4>${meta.name || "Token " + id}</h4>
            <p style="font-size:12px">ID: ${id}</p>`;
          contenedorNFTs.appendChild(card);
        }
        statusNFTs.innerText = "";
        console.log("[‚úÖ]¬†Renderizado finalizado");
      } catch (err) {
        console.error("[‚ùå]¬†Error en cargarMisNFTs", err);
        statusNFTs.innerText = "Error: " + err.message;
      }
    }

    /* ============================================================= */
    /* ===               LISTENERS DE INTERFAZ                   ==== */
    /* ============================================================= */

    btnRefrescar.addEventListener("click", cargarMisNFTs);
    document
      .querySelector('button[data-seccion="misnfts"]')
      .addEventListener("click", cargarMisNFTs);




  </script>
</body>
</html>
